<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Attack Graph with Sigma.js</title>
  <script src="https://cdn.jsdelivr.net/npm/graphology@0.25.1/dist/graphology.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/graphology-layout-forceatlas2@0.10.1/dist/index.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@2.4.0/build/sigma.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.11.8/umd/popper.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tippy.js/6.3.7/tippy-bundle.umd.min.js"></script>
    
  <style>
    #container {
      width: 100%;
      height: 600px;
      border: 1px solid #ccc;
      position: relative;
    }
    .tippy-box {
      background: white;
      border: 1px solid #333;
      padding: 5px;
      font-size: 12px;
      max-width: 250px;
    }
  </style>
</head>
<body>
  <h1>Attack Graph Visualization with Sigma.js</h1>
  <div id="container"></div>
  <script>
    // Fetch the attack graph from your endpoint (e.g., /scan/3/latest)
    fetch('/scan/3/latest')
      .then(response => response.json())
      .then(data => {
        if (!data.attack_graph) {
          document.getElementById('container').innerHTML = "<p>No attack graph available.</p>";
          return;
        }

        // Prepare the graphology graph:
        const Graph = graphology;
        const graph = new Graph();

        // Build nodes from the attack graph data:
        data.attack_graph.nodes.forEach(node => {
          // Use temporary random positions; we will run a layout
          graph.addNode(node.id, {
            label: node.label || node.name || node.id,
            x: Math.random() * 100,
            y: Math.random() * 100,
            size: 10,
            color: (node.type === "function") ? "#0074D9" : "#FF4136",
            vulnerable: node.vulnerable,
            filepath: node.filepath,
            vulnerabilities: node.vulnerabilities || [],
            type: node.type
          });
        });

        // Build edges:
        data.attack_graph.links.forEach(link => {
          graph.addEdge(link.source, link.target, {
            label: link.label,
            color: link.attack_path ? "#FF0000" : "#ccc",
            size: 1
          });
        });

        // Apply a layout algorithm:
        // Option 1: ForceAtlas2 layout (for dynamic, force-directed)
        sigma.layouts.forceAtlas2.assign(graph, { iterations: 100 });
        // Option 2: Use dagre layout if preferred:
        // const dagreLayout = graphologyLayoutDagre;
        // dagreLayout.assign(graph, { rankDir: 'TB', nodeSep: 50, edgeSep: 30, rankSep: 75 });

        // Initialize Sigma:
        const container = document.getElementById('container');
        const renderer = new sigma.Sigma(graph, container, {
          defaultEdgeColor: '#ccc',
          defaultNodeColor: '#0074D9'
        });

        // Setup tooltips using Tippy.js:
        // We'll add a mousemove listener to the container and use sigma's getNodeAt to get the hovered node.
        let currentTooltip = null;

        container.addEventListener('mousemove', (event) => {
          // Get the node at the current mouse position
          const nodeId = renderer.getNodeAt(event.clientX, event.clientY);
          if (nodeId) {
            // If there is already a tooltip for this node, do nothing.
            if (currentTooltip && currentTooltip.nodeId === nodeId) return;
            // Otherwise, if a tooltip is showing for another node, hide it.
            if (currentTooltip) {
              currentTooltip.tip.destroy();
              currentTooltip = null;
            }
            // Get node data
            const nodeData = graph.getNodeAttributes(nodeId);
            // Build tooltip content:
            let content = `<strong>${nodeData.label}</strong><br>`;
            content += `<strong>File:</strong> ${nodeData.filepath}<br>`;
            if (nodeData.vulnerabilities && nodeData.vulnerabilities.length > 0) {
              content += `<strong>Vulnerabilities:</strong><br>`;
              nodeData.vulnerabilities.forEach(vuln => {
                content += `<em>${vuln.message}</em> (Severity: ${vuln.severity}, Likelihood: ${vuln.likelihood}, Impact: ${vuln.impact})<br>`;
              });
            }
            // Optionally, list out edges (calls) from this node.
            const outEdges = graph.outEdges(nodeId);
            if (outEdges.length > 0) {
              content += `<strong>Calls:</strong><br>`;
              outEdges.forEach(edgeKey => {
                const edgeData = graph.getEdgeAttributes(edgeKey);
                content += `${edgeData.label} -> ${graph.getEdgeSource(edgeKey)}<br>`;
              });
            }
            // Create tooltip with Tippy.js:
            const tip = tippy(document.body, {
              content: content,
              allowHTML: true,
              interactive: true,
              placement: 'top',
              trigger: 'manual',
              animation: 'scale',
              theme: 'light-border'
            });
            tip.show();
            currentTooltip = { nodeId, tip };
          } else {
            if (currentTooltip) {
              currentTooltip.tip.destroy();
              currentTooltip = null;
            }
          }
        });

        container.addEventListener('mouseleave', () => {
          if (currentTooltip) {
            currentTooltip.tip.destroy();
            currentTooltip = null;
          }
        });

      })
      .catch(error => {
        console.error("Error fetching scan results:", error);
      });
  </script>
</body>
</html>
